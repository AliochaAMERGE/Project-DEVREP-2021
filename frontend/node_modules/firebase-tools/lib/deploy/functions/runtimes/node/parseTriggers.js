"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addResourcesToBackend = exports.discoverBackend = exports.useStrategy = exports.GCS_EVENTS = void 0;
const path = require("path");
const _ = require("lodash");
const child_process_1 = require("child_process");
const error_1 = require("../../../../error");
const logger_1 = require("../../../../logger");
const backend = require("../../backend");
const api = require("../../../../api");
const proto = require("../../../../gcp/proto");
const TRIGGER_PARSER = path.resolve(__dirname, "./triggerParser.js");
exports.GCS_EVENTS = new Set([
    "google.cloud.storage.object.v1.finalized",
    "google.cloud.storage.object.v1.archived",
    "google.cloud.storage.object.v1.deleted",
    "google.cloud.storage.object.v1.metadataUpdated",
]);
function removeInspectOptions(options) {
    return options.filter((opt) => !opt.startsWith("--inspect"));
}
function parseTriggers(projectId, sourceDir, configValues, envs) {
    return new Promise((resolve, reject) => {
        const env = Object.assign({}, envs);
        env.GCLOUD_PROJECT = projectId;
        if (!_.isEmpty(configValues)) {
            env.CLOUD_RUNTIME_CONFIG = JSON.stringify(configValues);
        }
        const execArgv = removeInspectOptions(process.execArgv);
        if (env.NODE_OPTIONS) {
            env.NODE_OPTIONS = removeInspectOptions(env.NODE_OPTIONS.split(" ")).join(" ");
        }
        const parser = child_process_1.fork(TRIGGER_PARSER, [sourceDir], {
            silent: true,
            env: env,
            execArgv: execArgv,
        });
        parser.on("message", (message) => {
            if (message.triggers) {
                resolve(message.triggers);
            }
            else if (message.error) {
                reject(new error_1.FirebaseError(message.error, { exit: 1 }));
            }
        });
        parser.on("exit", (code) => {
            if (code !== 0) {
                reject(new error_1.FirebaseError("There was an unknown problem while trying to parse function triggers.", { exit: 2 }));
            }
        });
    });
}
function useStrategy(context) {
    return Promise.resolve(true);
}
exports.useStrategy = useStrategy;
async function discoverBackend(projectId, sourceDir, runtime, configValues, envs) {
    const triggerAnnotations = await parseTriggers(projectId, sourceDir, configValues, envs);
    const want = Object.assign(Object.assign({}, backend.empty()), { environmentVariables: envs });
    for (const annotation of triggerAnnotations) {
        addResourcesToBackend(projectId, runtime, annotation, want);
    }
    return want;
}
exports.discoverBackend = discoverBackend;
function addResourcesToBackend(projectId, runtime, annotation, want) {
    var _a;
    Object.freeze(annotation);
    for (const region of annotation.regions || [api.functionsDefaultRegion]) {
        let triggered;
        const triggerCount = +!!annotation.httpsTrigger + +!!annotation.eventTrigger + +!!annotation.taskQueueTrigger;
        if (triggerCount != 1) {
            throw new error_1.FirebaseError("Unexpected annotation generated by the Firebase Functions SDK. This should never happen.");
        }
        if (annotation.taskQueueTrigger) {
            triggered = { taskQueueTrigger: annotation.taskQueueTrigger };
            want.requiredAPIs["cloudtasks"] = "cloudtasks.googleapis.com";
        }
        else if (annotation.httpsTrigger) {
            const trigger = {};
            if (annotation.failurePolicy) {
                logger_1.logger.warn(`Ignoring retry policy for HTTPS function ${annotation.name}`);
            }
            proto.copyIfPresent(trigger, annotation.httpsTrigger, "invoker");
            triggered = { httpsTrigger: trigger };
        }
        else if (annotation.schedule) {
            want.requiredAPIs["pubsub"] = "pubsub.googleapis.com";
            want.requiredAPIs["scheduler"] = "cloudscheduler.googleapis.com";
            triggered = { scheduleTrigger: annotation.schedule };
        }
        else {
            triggered = {
                eventTrigger: {
                    eventType: annotation.eventTrigger.eventType,
                    eventFilters: {
                        resource: annotation.eventTrigger.resource,
                    },
                    retry: !!annotation.failurePolicy,
                },
            };
            if (exports.GCS_EVENTS.has(((_a = annotation.eventTrigger) === null || _a === void 0 ? void 0 : _a.eventType) || "")) {
                triggered.eventTrigger.eventFilters = {
                    bucket: annotation.eventTrigger.resource,
                };
            }
        }
        const endpoint = Object.assign({ platform: annotation.platform || "gcfv1", id: annotation.name, region: region, project: projectId, entryPoint: annotation.entryPoint, runtime: runtime }, triggered);
        if (annotation.vpcConnector) {
            let maybeId = annotation.vpcConnector;
            if (!maybeId.includes("/")) {
                maybeId = `projects/${projectId}/locations/${region}/connectors/${maybeId}`;
            }
            endpoint.vpcConnector = maybeId;
        }
        proto.copyIfPresent(endpoint, annotation, "concurrency", "serviceAccountEmail", "labels", "vpcConnectorEgressSettings", "ingressSettings", "timeout", "maxInstances", "minInstances", "availableMemoryMb");
        want.endpoints[region] = want.endpoints[region] || {};
        want.endpoints[region][endpoint.id] = endpoint;
    }
}
exports.addResourcesToBackend = addResourcesToBackend;
